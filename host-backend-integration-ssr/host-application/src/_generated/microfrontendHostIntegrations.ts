/**
 * This file was automatically generated by OMG (OpenMicrofrontends Generator).
 * DO NOT MODIFY!
 */

import { createProxyServer } from 'http-proxy-3';
import type { ServerResponse, IncomingMessage } from 'node:http';
import type { OpenMicrofrontendsClientContext } from '@open-microfrontends/types/OpenMicrofrontendsRendererFunction';

import type { OpenMicrofrontendsServerContext } from '@open-microfrontends/types/OpenMicrofrontendsServerSideRendererFunction';

interface Logger {
  debug(msg: string, ...args: any[]): void;
  info(msg: string, ...args: any[]): void;
  warn(msg: string, ...args: any[]): void;
  error(msg: string, ...args: any[]): void;
}

type ImportMap = {
  imports: Record<string, string>;
};

const DEFAULT_MICROFRONTEND_REQUEST_TIMEOUT_SEC = 5;
const DEFAULT_API_PROXY_TIMEOUT_SEC = 60;
const DEFAULT_SSR_TIMEOUT_SEC = 5;

function toFullUrl(...parts: Array<string>): string {
  return parts
    .filter((part, idx) => part && part.trim() && (idx === 0 || part !== '/'))
    .map((part) => (part.endsWith('/') ? part.slice(0, -1) : part))
    .map((part, idx) => (idx > 0 && part.startsWith('/') ? part.substring(1) : part))
    .join('/');
}

/* TypeScript type from Schemas */

export interface Microfrontend1Config {
  /**
   * The customer ID
   */
  customerId: string;
  [k: string]: unknown;
}

/*
 * The setup calculated by the Host Application backend
 */
type HostBackendMicrofrontendSetup = Pick<
  OpenMicrofrontendsClientContext<any, any, any, any, any>,
  'lang' | 'user' | 'permissions' | 'hostContext'
> & {
  readonly assetBuildTimestampOrVersion?: string;
  readonly rewrittenImportMaps?: {
    readonly imports: Record<string, string>;
  };
};

const omBasePath = '/__om__';
const omAssetsSubPath = '/assets';
const omProxiesSubPath = '/proxies';
const omSetupSubPath = '/setup';

const getWithTimeoutAndExtraHeaders = async (
  url: string,
  baseUrl: string | null,
  timeoutSec: number,
  headers: Record<string, string>
): Promise<Response> => {
  const fullUrl = toFullUrl(baseUrl, url);
  return await fetch(fullUrl, {
    method: 'GET',
    headers: {
      ...headers,
    },
    signal: AbortSignal.timeout(timeoutSec * 1000),
  });
};

const postWithTimeoutAndExtraHeaders = async (
  url: string,
  baseUrl: string | null,
  body: object,
  timeoutSec: number,
  headers: Record<string, string>
): Promise<Response> => {
  const fullUrl = toFullUrl(baseUrl, url);
  return await fetch(fullUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...headers,
    },
    body: JSON.stringify(body),
    signal: AbortSignal.timeout(timeoutSec * 1000),
  });
};

/* Type Parameters */

export type Microfrontend1Permissions = undefined;

export interface OpenMicrofrontendsExampleSSRBaseSetup {
  microfrontendBaseUrl: string;
  microfrontendRequestTimeoutSec?: number;
  getUser(req: IncomingMessage): Promise<HostBackendMicrofrontendSetup['user'] | null>;
  getLang?(req: IncomingMessage): Promise<string | null>;
  getHostContext?: HostBackendMicrofrontendSetup['hostContext'];
  rewriteImportMaps?(importMaps: ImportMap): ImportMap;

  apiProxyTimeoutSec?: number;

  /*
   *  Security Headers for a request to the API Proxy bff.
   *  Schemes: [{"ApiKeyAuth":[]}]
   */
  apiProxyRequestBffGetSecurityHeaders(req: IncomingMessage): Promise<Record<string, string>>;

  microfrontendSSRTimeoutSec?: number;

  /*
   *  Security Headers for an SSR request to the Microfrontend
   *  Schemes: [{"ApiKeyAuth":[]}]
   */
  ssrGetSecurityHeaders(req: IncomingMessage): Promise<Record<string, string>>;

  /*
   * Add the SSR result to a cache
   * IMPORTANT: It might be necessary to add the user's name/id to the cache key if the render result depends on the authenticated user!
   */
  ssrCachePut?(key: string, userName: string | undefined, result: object): Promise<void>;
  /*
   * Get the SSR result from a cache
   */
  ssrCacheGet?(key: string, userName: string | undefined): Promise<object | null>;

  /*
   *  Custom logger
   */
  logger?: Logger;
}

const getOpenMicrofrontendsExampleSSRPermissions = async (
  req: IncomingMessage,
  username: string | undefined,
  baseSetup: OpenMicrofrontendsExampleSSRBaseSetup
): Promise<HostBackendMicrofrontendSetup['permissions']> => {
  return undefined;
};

const getOpenMicrofrontendsExampleSSRBuildTimestampOrVersion = async (
  baseSetup: OpenMicrofrontendsExampleSSRBaseSetup,
  logger: Logger
): Promise<string | undefined> => {
  return undefined;
};

const getOpenMicrofrontendsExampleSSRSetup = async (
  req: IncomingMessage,
  baseSetup: OpenMicrofrontendsExampleSSRBaseSetup,
  logger: Logger
): Promise<HostBackendMicrofrontendSetup> => {
  const user = await baseSetup.getUser(req);
  return {
    lang: await baseSetup.getLang?.(req),
    user,
    permissions: await getOpenMicrofrontendsExampleSSRPermissions(req, user?.username, baseSetup),
    assetBuildTimestampOrVersion: await getOpenMicrofrontendsExampleSSRBuildTimestampOrVersion(baseSetup, logger),
    hostContext: baseSetup.getHostContext,
  };
};

export const openMicrofrontendsExampleSSRHostIntegrationMiddleware = (
  baseSetup: OpenMicrofrontendsExampleSSRBaseSetup
) => {
  const logger = baseSetup.logger || console;
  const proxy = createProxyServer({
    changeOrigin: true,
    ignorePath: true,
    followRedirects: false,
  });
  proxy.on('error', (err, req, res) => {
    logger.error(`[OpenMicrofrontends] Proxy error for Microfrontend OpenMicrofrontendsExampleSSR`, err);
    (res as ServerResponse).statusCode = 500;
    res.end();
  });

  return async (req: IncomingMessage, res: ServerResponse, next: (err?: any) => void) => {
    // Required by the SSR render function
    (req as any)['__om_base_setup_OpenMicrofrontendsExampleSSR__'] = baseSetup;

    let url = req.url;
    if (!url.startsWith(`${omBasePath}/OpenMicrofrontendsExampleSSR`)) {
      next();
      return;
    }

    url = url.replace(`${omBasePath}/OpenMicrofrontendsExampleSSR`, '');
    logger.debug('[OpenMicrofrontends] Processing request for Microfrontend OpenMicrofrontendsExampleSSR:', url);

    if (req.method === 'GET' && url === omSetupSubPath) {
      try {
        const config = await getOpenMicrofrontendsExampleSSRSetup(req, baseSetup, logger);
        res.setHeader('Content-Type', 'application/json');
        res.end(JSON.stringify(config));
        return;
      } catch (e) {
        logger.error(
          '[OpenMicrofrontends] Error while processing config request for Microfrontend OpenMicrofrontendsExampleSSR',
          e
        );
        res.statusCode = 500;
        res.end();
        return;
      }
    }

    if (req.method === 'GET' && url.startsWith(omAssetsSubPath)) {
      const targetAssetPath = toFullUrl(baseSetup.microfrontendBaseUrl, '/', url.replace(omAssetsSubPath, ''));
      try {
        proxy.web(req, res, {
          target: targetAssetPath,
          timeout: (baseSetup.microfrontendRequestTimeoutSec ?? DEFAULT_MICROFRONTEND_REQUEST_TIMEOUT_SEC) * 1000,
        });
        return;
      } catch (e) {
        logger.error(
          `[OpenMicrofrontends] Error while fetching asset ${targetAssetPath} for Microfrontend OpenMicrofrontendsExampleSSR`,
          e
        );
        res.statusCode = 500;
        res.end();
        return;
      }
    }

    if (url.startsWith(omProxiesSubPath)) {
      let proxyUrl = url.replace(omProxiesSubPath, '');

      if (proxyUrl.startsWith('/bff')) {
        proxyUrl = proxyUrl.replace('/bff', '');
        const securityHeaders = await baseSetup.apiProxyRequestBffGetSecurityHeaders(req);
        const proxyTargetPath = toFullUrl(baseSetup.microfrontendBaseUrl, '/api', proxyUrl);

        try {
          proxy.web(req, res, {
            target: proxyTargetPath,
            headers: securityHeaders,
            timeout: (baseSetup.apiProxyTimeoutSec ?? DEFAULT_API_PROXY_TIMEOUT_SEC) * 1000,
          });
          return;
        } catch (e) {
          logger.error(
            `[OpenMicrofrontends] Error while forwarding call to proxy 'bff' for Microfrontend OpenMicrofrontendsExampleSSR. Target: ${req.method} ${proxyTargetPath}`,
            e
          );
          res.statusCode = 500;
          res.end();
          return;
        }
      }
    }

    next();
  };
};

type SSRContext = OpenMicrofrontendsServerContext<Partial<Microfrontend1Config>, Microfrontend1Permissions>;
type SSRResponse = {
  readonly contentHtml: string;
  readonly headHtml: string;
};

export const openMicrofrontendsExampleSSRServerSideRender = async (
  req: IncomingMessage,
  context: SSRContext
): Promise<SSRResponse> => {
  const baseSetup = (req as any)['__om_base_setup_OpenMicrofrontendsExampleSSR__'] as
    | OpenMicrofrontendsExampleSSRBaseSetup
    | undefined;
  if (!baseSetup) {
    throw new Error('[OpenMicrofrontends] Not setup found. Did you forget to register the generated middleware?');
  }

  const logger = baseSetup.logger || console;
  const defaultConfig = {
    customerId: '1000',
  };
  const contextWithDefaultConfig = {
    ...context,
    config: {
      ...defaultConfig,
      ...context.config,
    },
  };

  const securityHeaders = await baseSetup.ssrGetSecurityHeaders(req);

  const response = await postWithTimeoutAndExtraHeaders(
    '/ssr',
    baseSetup.microfrontendBaseUrl,
    contextWithDefaultConfig,
    baseSetup.microfrontendSSRTimeoutSec ?? DEFAULT_SSR_TIMEOUT_SEC,
    securityHeaders
  );
  if (!response.ok) {
    throw new Error(`[OpenMicrofrontends] SSR request failed with status ${response.status}`);
  }

  const { html, injectHeadScript } = await response.json();

  const assetsPath = `${omBasePath}/OpenMicrofrontendsExampleSSR${omAssetsSubPath}`;
  const fallbackAssetTimestamp = Math.floor(Date.now() / 10000) * 10;
  const assetBuildTimestampOrVersion = await getOpenMicrofrontendsExampleSSRBuildTimestampOrVersion(baseSetup, logger);

  const headHtml = `
            
                <!-- Add stylesheets to the head, so the pre-rendered HTML is already styled -->
                
                    <link href="${assetsPath}/style.css?v=${assetBuildTimestampOrVersion ?? fallbackAssetTimestamp}" rel="stylesheet" />
                
            
            <script>window['__om_ssr_OpenMicrofrontendsExampleSSR_${context.id}__'] = true;</script>
            ${injectHeadScript ? `<script>${injectHeadScript}</script>` : ''}
        `;

  return {
    contentHtml: html,
    headHtml,
  };
};
