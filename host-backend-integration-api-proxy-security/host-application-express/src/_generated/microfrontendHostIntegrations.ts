/**
 * This file was automatically generated by OMG (OpenMicrofrontends Generator).
 * DO NOT MODIFY!
 */

import { createProxyServer } from 'http-proxy-3';
import type { ServerResponse, IncomingMessage } from 'node:http';
import type { OpenMicrofrontendsClientContext } from '@open-microfrontends/types/OpenMicrofrontendsRenderer';

interface Logger {
  debug(msg: string, ...args: any[]): void;
  info(msg: string, ...args: any[]): void;
  warn(msg: string, ...args: any[]): void;
  error(msg: string, ...args: any[]): void;
}

type ImportMap = {
  imports: Record<string, string>;
};

const DEFAULT_MICROFRONTEND_REQUEST_TIMEOUT_SEC = 5;
const DEFAULT_API_PROXY_TIMEOUT_SEC = 60;
const DEFAULT_SSR_TIMEOUT_SEC = 5;

function toFullUrl(...parts: Array<string>): string {
  return parts
    .filter((part, idx) => part && part.trim() && (idx === 0 || part !== '/'))
    .map((part) => (part.endsWith('/') ? part.slice(0, -1) : part))
    .map((part, idx) => (idx > 0 && part.startsWith('/') ? part.substring(1) : part))
    .join('/');
}

/* TypeScript type from Schemas */

export interface Microfrontend1Config {
  /**
   * The customer ID
   */
  customerId: string;
  [k: string]: unknown;
}

/*
 * The setup calculated by the Host Application backend
 */
type HostBackendMicrofrontendSetup = Pick<
  OpenMicrofrontendsClientContext<any, any, any, any, any>,
  'lang' | 'user' | 'permissions' | 'hostContext'
> & {
  readonly assetBuildTimestampOrVersion?: string;
  readonly rewrittenImportMaps?: {
    readonly imports: Record<string, string>;
  };
};

const omBasePath = '/__om__';
const omAssetsSubPath = '/assets';
const omProxiesSubPath = '/proxies';
const omSetupSubPath = '/setup';

const getWithTimeoutAndExtraHeaders = async (
  url: string,
  baseUrl: string | null,
  timeoutSec: number,
  headers: Record<string, string>
): Promise<Response> => {
  const fullUrl = toFullUrl(baseUrl, url);
  return await fetch(fullUrl, {
    method: 'GET',
    headers: {
      ...headers,
    },
    signal: AbortSignal.timeout(timeoutSec * 1000),
  });
};

const postWithTimeoutAndExtraHeaders = async (
  url: string,
  baseUrl: string | null,
  body: object,
  timeoutSec: number,
  headers: Record<string, string>
): Promise<Response> => {
  const fullUrl = toFullUrl(baseUrl, url);
  return await fetch(fullUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...headers,
    },
    body: JSON.stringify(body),
    signal: AbortSignal.timeout(timeoutSec * 1000),
  });
};

/* Type Parameters */

export type Microfrontend1Permissions = {
  readonly showJoke: boolean;
};

export interface OpenMicrofrontendsExampleAPIProxyWithSecurityBaseSetup {
  microfrontendBaseUrl: string;
  microfrontendRequestTimeoutSec?: number;
  getUser(req: IncomingMessage): Promise<HostBackendMicrofrontendSetup['user'] | null>;
  getLang?(req: IncomingMessage): Promise<string | null>;
  getHostContext?: HostBackendMicrofrontendSetup['hostContext'];
  rewriteImportMaps?(importMaps: ImportMap): ImportMap;

  apiProxyTimeoutSec?: number;

  /*
   *  Security Headers for a request to the API Proxy bff.
   *  Schemes: [{"ApiKeyAuth":[]}]
   */
  apiProxyRequestBffGetSecurityHeaders(req: IncomingMessage): Promise<Record<string, string>>;

  /*
   *  Target URL of the API Proxy chuckNorrisJoke
   */
  apiProxyChuckNorrisJokeUrl: string;

  /*
   *  Security Headers for a user permissions request to the Microfrontend
   *  Schemes: [{"ApiKeyAuth":[]}]
   */
  userPermissionsRequestGetSecurityHeaders(req: IncomingMessage): Promise<Record<string, string>>;

  /*
   * Add build manifest to a cache (should not be cached more than 5min)
   */
  buildTimestampOrVersionCachePut(tsOrVersion: string): Promise<void>;
  /*
   * Get the build manifest from a cache
   */
  buildTimestampOrVersionCacheGet(): Promise<string | null>;

  /*
   * Add the user permissions for the current user to a cache
   */
  userPermissionsCachePut?(key: string, userPermissions: object): Promise<void>;
  /*
   * Get the user permissions for the current user from a cache
   */
  userPermissionsCacheGet?(key: string): Promise<object | null>;

  /*
   *  Custom logger
   */
  logger?: Logger;
}

const getOpenMicrofrontendsExampleAPIProxyWithSecurityPermissions = async (
  req: IncomingMessage,
  username: string | undefined,
  baseSetup: OpenMicrofrontendsExampleAPIProxyWithSecurityBaseSetup
): Promise<HostBackendMicrofrontendSetup['permissions']> => {
  let cacheKey;
  if (username) {
    cacheKey = `__om_user_permissions__${username}`;
    var permissionsFromCache = await baseSetup.userPermissionsCacheGet?.(cacheKey);
    if (permissionsFromCache) {
      return permissionsFromCache;
    }
  }

  const extraHeaders = await baseSetup.userPermissionsRequestGetSecurityHeaders(req);

  const res = await getWithTimeoutAndExtraHeaders(
    '/permissions',
    baseSetup.microfrontendBaseUrl,
    baseSetup.microfrontendRequestTimeoutSec ?? DEFAULT_MICROFRONTEND_REQUEST_TIMEOUT_SEC,
    extraHeaders
  );
  if (!res.ok) {
    throw new Error(`[OpenMicrofrontends] Error while requesting permissions from /permissions: ${res.statusText}`);
  }
  const permissions = await res.json();

  if (cacheKey) {
    await baseSetup.userPermissionsCachePut?.(cacheKey, permissions);
  }

  return permissions;
};

const getOpenMicrofrontendsExampleAPIProxyWithSecurityBuildTimestampOrVersion = async (
  baseSetup: OpenMicrofrontendsExampleAPIProxyWithSecurityBaseSetup,
  logger: Logger
): Promise<string | undefined> => {
  const buildTimestampOrVersionFromCache = await baseSetup.buildTimestampOrVersionCacheGet();
  if (buildTimestampOrVersionFromCache) {
    return buildTimestampOrVersionFromCache;
  }
  try {
    const res = await getWithTimeoutAndExtraHeaders(
      '/package.json',
      baseSetup.microfrontendBaseUrl,
      baseSetup.microfrontendRequestTimeoutSec ?? DEFAULT_MICROFRONTEND_REQUEST_TIMEOUT_SEC,
      {}
    );
    if (!res.ok) {
      logger.warn(`[OpenMicrofrontends] Error while fetching build manifest from /package.json: ${res.statusText}`);
      return undefined;
    }
    const buildManifest = await res.json();
    const buildTimestampOrVersion = buildManifest.timestamp || buildManifest.version;
    if (!buildTimestampOrVersion) {
      logger.warn('[OpenMicrofrontends] No build timestamp or version found in build manifest:', buildManifest);
    } else {
      await baseSetup.buildTimestampOrVersionCachePut(buildTimestampOrVersion);
    }
    return buildTimestampOrVersion;
  } catch (e) {
    logger.warn('[OpenMicrofrontends] Error while fetching build manifest from /package.json!', e);
  }
  return undefined;
};

const getOpenMicrofrontendsExampleAPIProxyWithSecuritySetup = async (
  req: IncomingMessage,
  baseSetup: OpenMicrofrontendsExampleAPIProxyWithSecurityBaseSetup,
  logger: Logger
): Promise<HostBackendMicrofrontendSetup> => {
  const user = await baseSetup.getUser(req);
  return {
    lang: await baseSetup.getLang?.(req),
    user,
    permissions: await getOpenMicrofrontendsExampleAPIProxyWithSecurityPermissions(req, user?.username, baseSetup),
    assetBuildTimestampOrVersion: await getOpenMicrofrontendsExampleAPIProxyWithSecurityBuildTimestampOrVersion(
      baseSetup,
      logger
    ),
    hostContext: baseSetup.getHostContext,
  };
};

export const openMicrofrontendsExampleAPIProxyWithSecurityHostIntegrationMiddleware = (
  baseSetup: OpenMicrofrontendsExampleAPIProxyWithSecurityBaseSetup
) => {
  const logger = baseSetup.logger || console;
  const proxy = createProxyServer({
    changeOrigin: true,
    ignorePath: true,
    followRedirects: false,
  });
  proxy.on('error', (err, req, res) => {
    logger.error(
      `[OpenMicrofrontends] Proxy error for Microfrontend OpenMicrofrontendsExampleAPIProxyWithSecurity`,
      err
    );
    (res as ServerResponse).statusCode = 500;
    res.end();
  });

  return async (req: IncomingMessage, res: ServerResponse, next: (err?: any) => void) => {
    // Required by the SSR Renderer
    (req as any)['__om_base_setup_OpenMicrofrontendsExampleAPIProxyWithSecurity__'] = baseSetup;

    let url = req.url;
    if (!url.startsWith(`${omBasePath}/OpenMicrofrontendsExampleAPIProxyWithSecurity`)) {
      next();
      return;
    }

    url = url.replace(`${omBasePath}/OpenMicrofrontendsExampleAPIProxyWithSecurity`, '');
    logger.debug(
      '[OpenMicrofrontends] Processing request for Microfrontend OpenMicrofrontendsExampleAPIProxyWithSecurity:',
      url
    );

    if (req.method === 'GET' && url === omSetupSubPath) {
      try {
        const config = await getOpenMicrofrontendsExampleAPIProxyWithSecuritySetup(req, baseSetup, logger);
        res.setHeader('Content-Type', 'application/json');
        res.end(JSON.stringify(config));
        return;
      } catch (e) {
        logger.error(
          '[OpenMicrofrontends] Error while processing config request for Microfrontend OpenMicrofrontendsExampleAPIProxyWithSecurity',
          e
        );
        res.statusCode = 500;
        res.end();
        return;
      }
    }

    if (req.method === 'GET' && url.startsWith(omAssetsSubPath)) {
      const targetAssetPath = toFullUrl(baseSetup.microfrontendBaseUrl, '/public', url.replace(omAssetsSubPath, ''));
      try {
        proxy.web(req, res, {
          target: targetAssetPath,
          timeout: (baseSetup.microfrontendRequestTimeoutSec ?? DEFAULT_MICROFRONTEND_REQUEST_TIMEOUT_SEC) * 1000,
        });
        return;
      } catch (e) {
        logger.error(
          `[OpenMicrofrontends] Error while fetching asset ${targetAssetPath} for Microfrontend OpenMicrofrontendsExampleAPIProxyWithSecurity`,
          e
        );
        res.statusCode = 500;
        res.end();
        return;
      }
    }

    if (url.startsWith(omProxiesSubPath)) {
      let proxyUrl = url.replace(omProxiesSubPath, '');

      if (proxyUrl.startsWith('/bff')) {
        proxyUrl = proxyUrl.replace('/bff', '');
        const securityHeaders = await baseSetup.apiProxyRequestBffGetSecurityHeaders(req);
        const proxyTargetPath = toFullUrl(baseSetup.microfrontendBaseUrl, '/api', proxyUrl);

        try {
          proxy.web(req, res, {
            target: proxyTargetPath,
            headers: securityHeaders,
            timeout: (baseSetup.apiProxyTimeoutSec ?? DEFAULT_API_PROXY_TIMEOUT_SEC) * 1000,
          });
          return;
        } catch (e) {
          logger.error(
            `[OpenMicrofrontends] Error while forwarding call to proxy 'bff' for Microfrontend OpenMicrofrontendsExampleAPIProxyWithSecurity. Target: ${req.method} ${proxyTargetPath}`,
            e
          );
          res.statusCode = 500;
          res.end();
          return;
        }
      }

      if (proxyUrl.startsWith('/chuckNorrisJoke')) {
        proxyUrl = proxyUrl.replace('/chuckNorrisJoke', '');
        const securityHeaders = {};
        const proxyTargetPath = toFullUrl(baseSetup.apiProxyChuckNorrisJokeUrl, proxyUrl);

        try {
          proxy.web(req, res, {
            target: proxyTargetPath,
            headers: securityHeaders,
            timeout: (baseSetup.apiProxyTimeoutSec ?? DEFAULT_API_PROXY_TIMEOUT_SEC) * 1000,
          });
          return;
        } catch (e) {
          logger.error(
            `[OpenMicrofrontends] Error while forwarding call to proxy 'chuckNorrisJoke' for Microfrontend OpenMicrofrontendsExampleAPIProxyWithSecurity. Target: ${req.method} ${proxyTargetPath}`,
            e
          );
          res.statusCode = 500;
          res.end();
          return;
        }
      }
    }

    next();
  };
};

export const openMicrofrontendsExampleAPIProxyWithSecurityAnnotations = {
  MY_COCKPIT_INTEGRATION: { displays: 'CUSTOMER' },
};
